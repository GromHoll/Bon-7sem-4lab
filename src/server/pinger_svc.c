/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 *
 *********************************
 *
 * Pf...
 * Trust me, i'm engineer!
 *
 */

#include "pinger.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>

/* Added by me */
#include <string.h>
#include <ctime>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>

////////////////////////
#include <iostream>
using namespace std;
////////////////////////


#define MAX_HOSTS 100
#define REMOVED_HOST "REMOVED"

struct hosts {
	hostStatus arr[MAX_HOSTS];
	time_t lastTimeout[MAX_HOSTS];
	int size;
} list;

hostStatus hs; 
hostsList hl;

char hostsFileName[100];

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

/* Added by me */
bool loadHosts();

static void
pinger_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		hostName gethoststate_1_arg;
		hostName forcepinghost_1_arg;
		hostInfo sethosttimeout_1_arg;
		timeout setglobaltimeout_1_arg;
		hostInfo addhost_1_arg;
		hostName remotehost_1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc) {
	case getHostState:
		_xdr_argument = (xdrproc_t) xdr_hostName;
		_xdr_result = (xdrproc_t) xdr_hostStatus;
		local = (char *(*)(char *, struct svc_req *)) gethoststate_1_svc;
		break;

	case getAllHostStates:
		_xdr_argument = (xdrproc_t) xdr_void;
		_xdr_result = (xdrproc_t) xdr_hostsList;
		local = (char *(*)(char *, struct svc_req *)) getallhoststates_1_svc;
		break;

	case forcePingHost:
		_xdr_argument = (xdrproc_t) xdr_hostName;
		_xdr_result = (xdrproc_t) xdr_hostStatus;
		local = (char *(*)(char *, struct svc_req *)) forcepinghost_1_svc;
		break;

	case forcePingAllHosts:
		_xdr_argument = (xdrproc_t) xdr_void;
		_xdr_result = (xdrproc_t) xdr_hostsList;
		local = (char *(*)(char *, struct svc_req *)) forcepingallhosts_1_svc;
		break;

	case setHostTimeout:
		_xdr_argument = (xdrproc_t) xdr_hostInfo;
		_xdr_result = (xdrproc_t) xdr_void;
		local = (char *(*)(char *, struct svc_req *)) sethosttimeout_1_svc;
		break;

	case setGlobalTimeout:
		_xdr_argument = (xdrproc_t) xdr_timeout;
		_xdr_result = (xdrproc_t) xdr_void;
		local = (char *(*)(char *, struct svc_req *)) setglobaltimeout_1_svc;
		break;

	case addHost:
		_xdr_argument = (xdrproc_t) xdr_hostInfo;
		_xdr_result = (xdrproc_t) xdr_void;
		local = (char *(*)(char *, struct svc_req *)) addhost_1_svc;
		break;

	case remoteHost:
		_xdr_argument = (xdrproc_t) xdr_hostName;
		_xdr_result = (xdrproc_t) xdr_void;
		local = (char *(*)(char *, struct svc_req *)) remotehost_1_svc;
		break;

	default:
		svcerr_noproc (transp);
		return;
	}
	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
		svcerr_systemerr (transp);
	}
	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		fprintf (stderr, "%s", "unable to free arguments");
		exit (1);
	}
	return;
}

int
main (int argc, char **argv)
{
	/* Added by me */
	if(argc != 2) {
		fprintf (stderr, "%s%s%s", "Incorrect arguments.\n Use ", argv[0], " <filename>");
		exit(1);
	}

	register SVCXPRT *transp;

	pmap_unset (PINGER, PINGER_VERS_1);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, PINGER, PINGER_VERS_1, pinger_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (PINGER, PINGER_VERS_1, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, PINGER, PINGER_VERS_1, pinger_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (PINGER, PINGER_VERS_1, tcp).");
		exit(1);
	}

	/* Added by me */
	if(argc != 2) {
		fprintf (stderr, "%s", "unable to load information about hosts.");
		exit(1);
	}

	strcpy(hostsFileName, argv[1]);

	hs.status = SLEEP;
	strcpy(hs.host.host, "Unknow host");

	hl.hostsList_val = list.arr;

	if(!loadHosts()) {
		fprintf (stderr, "%s", "unable to load information about hosts.");
		exit(1);
	}

	svc_run ();
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}

/* Added by me */
void pingHost(hostStatus * h, time_t & lastUpdate, bool force) {

	if(!force) {
		if(h->host.duration == MANUAL_FORCE_TIMEOUT)
			return;
		else if(difftime(time(NULL), lastUpdate) <  h->host.duration)
			return;
	}

	int ping_pid = fork();
	if(ping_pid < 0) {
		fprintf (stderr, "%s", "Can't run ping program.");
		exit(1);
	} else if(ping_pid > 0) {
		/* Parent */
		int status;
		waitpid(ping_pid, &status, 0);

		if(status == 0) {
			h->status = AVAILIBLE;
		} else {
			h->status = SLEEP;		
		}

		lastUpdate = time(NULL);
	} else {
		/* Child */
		execl("/bin/ping", "/bin/ping", "-c", "1", h->host.host, NULL);
		fprintf (stderr, "%s", "Can't run ping program.");
		exit(1);
	}	
}

void pingAll(bool force) {

	hl.hostsList_len = list.size;
	for(int i = 0; i < list.size; i++) {
		pingHost(&list.arr[i], list.lastTimeout[i], force);
	}
}

bool loadHosts() {	

	list.size = 0;

	FILE * file = fopen(hostsFileName, "r");
	if(file == NULL) return false;

	char buffer[33];

	while(!feof(file)) {
		if(fgets(buffer, 32, file) != NULL) {

			if(strlen(buffer) > 1) {
				sscanf(buffer, "%s %li", 
						list.arr[list.size].host.host,
						&list.arr[list.size].host.duration);
				list.size++;
			}
		}
	}	

	fclose(file);

	pingAll(true);

	return true;
}

void saveHosts() {	

	FILE * file = fopen(hostsFileName, "w");
	if(file == NULL) return;

	for(int i = 0; i < list.size; i++) {
		if(strcmp(list.arr[i].host.host, REMOVED_HOST) != 0)
			fprintf(file, "%s %li\n", list.arr[i].host.host, list.arr[i].host.duration);
	}
	fclose(file);
}

hostStatus * gethoststate_1_svc(char * host, struct svc_req * req) {

	for(int i = 0; i < list.size; i++) {
		if(strcmp(host, list.arr[i].host.host) == 0) {

			pingHost(&list.arr[i], list.lastTimeout[i], false);
			return &(list.arr[i]);
		}
	}

	return &hs;
}

hostsList * getallhoststates_1_svc(void * v, struct svc_req * req) {
	pingAll(false);
	return &hl;
}

hostStatus * forcepinghost_1_svc(char * host, struct svc_req * req) {

	for(int i = 0; i < list.size; i++) {
		if(strcmp(host, list.arr[i].host.host) == 0) {

			pingHost(&list.arr[i], list.lastTimeout[i], true);
			return &(list.arr[i]);
		}
	}

	return &hs;
}

hostsList * forcepingallhosts_1_svc(void * v, struct svc_req * req) {
	pingAll(true);
	return &hl;
}

void * sethosttimeout_1_svc(hostInfo * hostI, struct svc_req * req) {	
	for(int i = 0; i < list.size; i++) {
		if(strcmp(hostI->host, list.arr[i].host.host) == 0) {
			list.arr[i].host.duration = hostI->duration;
		}
	}
	saveHosts();
	return &hs;
}

void * setglobaltimeout_1_svc(timeout * t, struct svc_req * req) {
	for(int i = 0; i < list.size; i++) {
		list.arr[i].host.duration = *t;
	}
	saveHosts();
	return &hs;
}

void * addhost_1_svc(hostInfo * hostI, struct svc_req * req) {

	if(list.size >= MAX_HOSTS)
		printf("Max hosts count.\n");
	else {
		strcpy(list.arr[list.size].host.host, hostI->host);
		list.arr[list.size].host.duration = hostI->duration;

		pingHost(&list.arr[list.size], list.lastTimeout[list.size], true);
		list.size++;

		saveHosts();
	}

	return &hs;
}

void * remotehost_1_svc(char * host, struct svc_req * req) {
	for(int i = 0; i < list.size; i++) {
		if(strcmp(host, list.arr[i].host.host) == 0) {
			strcpy(list.arr[i].host.host, REMOVED_HOST);
		}
	}
	saveHosts();
	loadHosts();
	return &hs;
}
